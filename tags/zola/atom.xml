<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh">
	<title>Owen的博客 - Zola</title>
	<subtitle>主要关注技术，读书，摘抄，杂谈，文章评论，工具分享，工作流，灵感，英文学习，注意力管理，深度工作等方向</subtitle>
	<link href="https://www.owenyoung.com/tags/zola/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://www.owenyoung.com"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-07-12T21:11:21+08:00</updated>
	<id>https://www.owenyoung.com/tags/zola/atom.xml</id>
	<entry xml:lang="zh">
		<title>Zola 博客的中文阅读时间预估误差很大，所以我做了一个修复</title>
		<published>2022-07-12T21:11:21+08:00</published>
		<updated>2022-07-12T00:00:00+00:00</updated>
		<link rel="alternate" href="https://www.owenyoung.com/blog/reading-time/" type="text/html"/>
		<id>https://www.owenyoung.com/blog/reading-time/</id>
		<content type="html">&lt;p&gt;我发现 Zola 给中文文章的阅读时间预估特别高，比如我刚发布的这篇&lt;a href=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;blog&#x2F;add-search&#x2F;&quot;&gt;给 Zola 博客增加搜索功能&lt;&#x2F;a&gt;, 显示要 20 分钟才能阅读完:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;发布于: 2022-07-12 · 最后更新时间: 2022-07-12 · 阅读时间: 20 min&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;我就纳闷我这是写了一篇 essay 吗，于是就是查它的&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;getzola&#x2F;zola&#x2F;blob&#x2F;39cf436b1174a3d5f2fbe4bac20e942795005f05&#x2F;components&#x2F;content&#x2F;src&#x2F;utils.rs#L55-L61&quot;&gt;实现&lt;&#x2F;a&gt;, 发现实现很简单，就是基于 unicode 字符除以了一个数：&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Get word count and estimated reading time
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;get_reading_analytics&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;content&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; word_count: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= content.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unicode_words&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;count&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    (word_count, ((word_count + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;199&lt;&#x2F;span&gt;&lt;span&gt;) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;200&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后他在注释里链接了这个数字的&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;help.medium.com&#x2F;hc&#x2F;en-us&#x2F;articles&#x2F;214991667-Read-time&quot;&gt;来源&lt;&#x2F;a&gt;，证明它不是拍脑袋决定的, 来源是 &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;&quot;&gt;Medium&lt;&#x2F;a&gt; 的文档：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Read time is based on the average reading speed of an adult (roughly 265 WPM). We take the total word count of a post and translate it into minutes, with an adjustment made for images. For posts in Chinese, Japanese and Korean, it’s a function of number of characters (500 characters&#x2F;min) with an adjustment made for images.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;这篇文档说英文这类字符大约是 265 个单词每分钟，中日韩这类文字是 500 个字符每分钟，所以对于中文来讲，zola 这个计算是有大约 1 倍的误差的，所以我加了一个判断：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;njk&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-njk &quot;&gt;&lt;code class=&quot;language-njk&quot; data-lang=&quot;njk&quot;&gt;&lt;span&gt;{% macro get_reading_time(minutes) %}
&lt;&#x2F;span&gt;&lt;span&gt;  {% if lang==&amp;quot;zh&amp;quot; %}
&lt;&#x2F;span&gt;&lt;span&gt;    {{ minutes&#x2F;1.88 | round }}
&lt;&#x2F;span&gt;&lt;span&gt;  {% else %}
&lt;&#x2F;span&gt;&lt;span&gt;    {{ minutes }}
&lt;&#x2F;span&gt;&lt;span&gt;  {% endif %}
&lt;&#x2F;span&gt;&lt;span&gt;{% endmacro get_reading_time %}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后在&lt;code&gt;page.html&lt;&#x2F;code&gt;里可以这样调用：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;njk&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-njk &quot;&gt;&lt;code class=&quot;language-njk&quot; data-lang=&quot;njk&quot;&gt;&lt;span&gt;{{ macro::get_reading_time(minutes=page.reading_time) }}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样应该就能修正中文的预估时间了。修正后，开头提到的文章现在预估时间大约是 11 分钟，比较合理了。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>给Zola博客增加搜索功能</title>
		<published>2022-07-12T00:54:03+08:00</published>
		<updated>2022-07-12T00:00:00+00:00</updated>
		<link rel="alternate" href="https://www.owenyoung.com/blog/add-search/" type="text/html"/>
		<id>https://www.owenyoung.com/blog/add-search/</id>
		<content type="html">&lt;p&gt;我觉得个人博客的一个最大的好处就是我可以把它当成任何东西的试验田，弄坏也没事，反正这只是我的个人数字花园而已。所以昨天我给博客新加了一个&lt;a href=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;search&#x2F;&quot;&gt;搜索页面&lt;&#x2F;a&gt;，以及首页也添加了一个搜索框。&lt;&#x2F;p&gt;
&lt;p&gt;我一直在这个博客里存放自己的所有公开内容，包括笔记和文章，我经常需要搜索自己的笔记，在此之前，我一直用 VSCode 在本地搜索文档。但是 VSCode 其实启动挺慢的，而且如果不在电脑边，也没法用，所以最近就研究了几种搜索方案。最终我选择了自托管 Rust 开发的&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;meilisearch&#x2F;meilisearch&quot;&gt;Meilisearch&lt;&#x2F;a&gt;，但是这也不是特别理想的方案，因为需要在自己的 VPS 服务器上托管，对于静态博客来说，多了一环需要动态运行的服务需要维护。但是这已经是目前最不差的方案了。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;对于静态博客的搜索，我了解的主要有 4 种主流方案，一是客户端搜索，另一种是很流行的使用&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.algolia.com&#x2F;&quot;&gt;Algolia&lt;&#x2F;a&gt;的搜索托管服务，还有一种是使用搜索引擎比如谷歌的索引结果，最后就是我最终使用的 Algolia 的开源&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;meilisearch&#x2F;meilisearch&quot;&gt;替代方案 Meilisearch&lt;&#x2F;a&gt;这类的自托管。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ke-hu-duan-sou-suo&quot;&gt;客户端搜索&lt;a class=&quot;zola-anchor&quot; href=&quot;#ke-hu-duan-sou-suo&quot; aria-label=&quot;Anchor link for: ke-hu-duan-sou-suo&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;客户端搜索是最符合静态博客定义的，完全不依赖服务端，zola 博客内置的搜索功能也是这样，其原理是 build 的过程中，生成整个网站的搜索的 JSON 索引文件，在前端网页提出搜索请求后，用 js 去搜索这个索引，然后找出对应的结果。这个索引可大可小，如果你只索引标题和路径的话，那么索引就很小，但是如果你索引全文的话，取决于你的文档大小，索引可能会很大。Zola 目前内置的搜索使用 &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;weixsong&#x2F;elasticlunr.js&quot;&gt;elasticlunr&lt;&#x2F;a&gt;, 其实已经 3 年没有更新了，项目处于等继承者状态。另一个就是，这个基本上是不支持中文搜索的，虽然 Zola 有选项可以建立中文的搜索索引，但是前端库方面对于中文的支持处于不可用的状态，我试过接入，但是太多 bug 了，之前看到一个&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.jpgov.art&#x2F;posts&#x2F;japanese-full-text-search-on-zola&#x2F;&quot;&gt;日本博主好像确实有成功集成日文搜索&lt;&#x2F;a&gt;, 我仿照的时候也失败了。&lt;&#x2F;p&gt;
&lt;p&gt;为什么对于中文搜索需要专门支持呢？因为所有类似的全文搜索实现都是要先建立一个倒排索引（听起来很牛逼，其实就是词语对文章 id 的哈希索引），类似下面这样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Hello&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;hello&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;world&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;],
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;World&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;world&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;foo&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;]
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;有了这个索引，就能很快的找到最相关的文章。这种索引对于类似英语的语言来说很好实现，因为英语中分词很简单，只需要根据空格就能把所有词语分开，但是中文没有用空格分开的习惯，所以需要很大的词语字典，然后从字典里找到相关的词语，然后再建立分词索引。这才完成第一步（这个比较好解决，因为这一步发生在编译阶段，有足够的资源去做这件事）。第二步是从客户端发出搜索请求，这一步入依然需要分词，比如用户搜索&lt;code&gt;如何给zola博客添加索引&lt;&#x2F;code&gt;，搜索引擎首先要把这句话分为&lt;code&gt;如何&lt;&#x2F;code&gt;,&lt;code&gt;给&lt;&#x2F;code&gt;,&lt;code&gt;Zola&lt;&#x2F;code&gt;,&lt;code&gt;博客&lt;&#x2F;code&gt;,&lt;code&gt;添加&lt;&#x2F;code&gt;,&lt;code&gt;索引&lt;&#x2F;code&gt;，然后再去对应的索引里进行最佳匹配查询。所以我觉得对于中文搜索，在客户端做是不现实的，因为基本上没法在客户端上进行复杂的分词，而且随着文档的增加，全文搜索的索引还会进一步增加，全部加载到客户端看起来也不是一个很道德的选择。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;WASM 怎么样？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;webassembly.org&#x2F;&quot;&gt;WebAssembly&lt;&#x2F;a&gt; 以作为 js 的高性能支持方案进入了主流浏览器的支持，你可以用 Rust, C++，或者任何你喜欢的语言来编写高性能的 WebAssembly 应用，然后在前端调用。&lt;&#x2F;p&gt;
&lt;p&gt;对于 WASM，看到过几个有意思的项目，比如&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;phiresky&#x2F;sql.js-httpvfs&quot;&gt;sql.js-httpvfs&lt;&#x2F;a&gt;, 把 sqlite 数据文件存储到 CDN 服务器上，然后前端用含有内嵌 sqlite 的 wasm 去读取数据，充分利用了 sqlite 的高效，从而实现让 web 客户端完全摆脱服务端数据库的依赖。&lt;&#x2F;p&gt;
&lt;p&gt;我也找到了几个关于 WASM 搜索的项目，主要包括：&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tinysearch&#x2F;tinysearch&quot;&gt;tinysearch&lt;&#x2F;a&gt; ,&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jameslittle230&#x2F;stork&quot;&gt;stork&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;wilsonzlin&#x2F;edgesearch&quot;&gt;edgesearch&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tinysearch&quot;&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tinysearch&#x2F;tinysearch&quot;&gt;Tinysearch&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#tinysearch&quot; aria-label=&quot;Anchor link for: tinysearch&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;用 Rust 编写，原理和 js 客户端搜索基本类似，只不过把索引打包到 wasm 里面，最终的 wasm 大小可以是 100k 以内，但是也只支持英文。我把源码下载下来，然后把分词逻辑换用&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;meilisearch&#x2F;charabia&quot;&gt;Meilisearch 的分词&lt;&#x2F;a&gt;，尝试打包我目前的博客，发现总共也才 113K，这 113K 是同时包括搜索逻辑和索引数据的哦，而用 Zola 自带的搜索打包的纯中文索引数据是 3.5M,英文索引是 650K, 可见 tinysearch 的作者真的做了很多优化，作者也写了一篇&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;endler.dev&#x2F;2019&#x2F;tinysearch&#x2F;&quot;&gt;详细的文章&lt;&#x2F;a&gt;记录优化的过程。但其实这样对比是有一点不公平的，因为&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.getzola.org&#x2F;documentation&#x2F;getting-started&#x2F;overview&#x2F;&quot;&gt;Zola 的索引会有更好的搜索体验&lt;&#x2F;a&gt;，你可以在文档网站体验一下, 而&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;endler.dev&#x2F;2019&#x2F;tinysearch&quot;&gt;Tinysearch&lt;&#x2F;a&gt;则为了性能做了一些取舍，比如不支持前缀搜索，搜索结果只显示标题，没有上下文，也没有高亮等等，但是从性能角度，我觉得这种方案算是客户端搜索的天花板了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;stork&quot;&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jameslittle230&#x2F;stork&quot;&gt;Stork&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#stork&quot; aria-label=&quot;Anchor link for: stork&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;同样也是 Rust 编写，只支持英文，颜值很好，接入体验也很棒，搜索结果还能高亮，也有上下文，基本上和&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.algolia.com&#x2F;&quot;&gt;Algolia&lt;&#x2F;a&gt;类似，也使用了 wasm，不过 Stork 是把搜索逻辑单独打包成一个 wasm，然后把索引数据另外打包成另一个&lt;code&gt;st&lt;&#x2F;code&gt;文件，然后搜索的时候动态的加载索引数据。这样的操作其实多了一步序列化和反序列化的步骤。我也尝试把其内置的简单英文分词逻辑换用&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;meilisearch&#x2F;charabia&quot;&gt;Meilisearch 的分词&lt;&#x2F;a&gt;，但是发现我的索引数据竟然达到了 85M（可能有别的坑，因为我只是简单的替换了分词的函数），所以就没有更多的体验了。这也印证了，想在客户端把搜索体验做好，确实需要权衡你的索引大小。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;edgesearch&quot;&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;wilsonzlin&#x2F;edgesearch&quot;&gt;edgesearch&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#edgesearch&quot; aria-label=&quot;Anchor link for: edgesearch&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;我喜欢这个哥们的概念，无服务器 Serverless 搜索，通过把 WASM 部署到 Cloudflare Workers 上，然后客户端通过网络请求进行搜索，我觉得这是最有戏的方案，我喜欢 Cloudflare Workers 这种一次书写，永远忘记的无服务器系统，而且每天还有 10 万请求的免费额度，同时作为基于 Chrome V8 中有限制的无服务器，冷启动又贼快，所以我觉得静态博客的最佳搜索方案就是这样了。虽然有一点点动态，但是我们用了最具有扩展性的方案，我倾向于认为这是必要的权衡。说回 EdgeSearch，它也是先 build 索引，然后把索引上传到 cloudflare 的 KV 内存数据库里，然后通过 wasm load 索引，进行搜索，性能很高，只是它目前只是处于实验阶段，接入需要自定义很多东西，而且也不支持中文，我个人很希望这个项目能获得更多的牵引力。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nan-dao-zhi-neng-yong-yun-sou-suo-fu-wu-liao-ma&quot;&gt;难道只能用云搜索服务了吗？&lt;a class=&quot;zola-anchor&quot; href=&quot;#nan-dao-zhi-neng-yong-yun-sou-suo-fu-wu-liao-ma&quot; aria-label=&quot;Anchor link for: nan-dao-zhi-neng-yong-yun-sou-suo-fu-wu-liao-ma&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;algolia&quot;&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.algolia.com&#x2F;&quot;&gt;Algolia&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#algolia&quot; aria-label=&quot;Anchor link for: algolia&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;即刻搜索的鼻祖和天花板，我在&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;actionsflow.github.io&#x2F;docs&#x2F;&quot;&gt;Actionsflow 的文档网站&lt;&#x2F;a&gt;中用了他提供给开源项目的免费服务，接入和界面都是一流的，不信你去看&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;tailwindcss.com&#x2F;&quot;&gt;tailwindcss&lt;&#x2F;a&gt;的搜索体验，太棒了。唯一的问题就是贵，如果不差钱，那我觉得这是最佳选择了。他家同时也是&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;hn.algolia.com&#x2F;&quot;&gt;Hacker News&lt;&#x2F;a&gt;的御用搜索，我经常用来搜很多东西, 感谢感谢！&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sourcegraph&quot;&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;sourcegraph.com&#x2F;&quot;&gt;Sourcegraph&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#sourcegraph&quot; aria-label=&quot;Anchor link for: sourcegraph&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;我在&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ruanyf&#x2F;weekly&quot;&gt;阮老师的科技周刊&lt;&#x2F;a&gt;里看到阮老师给用户的其中一个搜索选项是利用 &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;sourcegraph.com&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&quot;&gt;https:&#x2F;&#x2F;sourcegraph.com&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&lt;&#x2F;a&gt; 提供的对 Github 源码的免费搜索服务，我试了一下，搜索准确度非常高，但是只能链接到源文件，没法回到对应的网页，但是由于博客内容是用 markdown 写的，所以纯文本也没问题。所以，这是一个不错的替代品。我在&lt;a href=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;search&#x2F;&quot;&gt;Search&lt;&#x2F;a&gt;也添加了一个表单搜索链接过去，你可以体验一下。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;vscode-web-ban-github1s&quot;&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github1s.com&#x2F;theowenyoung&#x2F;blog&quot;&gt;VSCode Web 版(Github1s)&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#vscode-web-ban-github1s&quot; aria-label=&quot;Anchor link for: vscode-web-ban-github1s&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;你只需要在 github 的网址上加上&lt;code&gt;1s&lt;&#x2F;code&gt;之后，就能用浏览器以 VSCode 的方式打开你的 github repo，比如我的博客对应的地址就是：&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github1s.com&#x2F;theowenyoung&#x2F;blog&quot;&gt;https:&#x2F;&#x2F;github1s.com&#x2F;theowenyoung&#x2F;blog&lt;&#x2F;a&gt; ，这里自带 VSCode 的全局搜索，所以就可以直接在浏览器上搜索博客内容，这其实也是一个很好的搜索替代方案，完全不用担心自己托管，搜索速度也超快，就是差一个直接指向搜索并且带搜索参数的链接，我提了一个&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;conwnet&#x2F;github1s&#x2F;issues&#x2F;428&quot;&gt;Issue&lt;&#x2F;a&gt;,结果他们回复其实他们用的是我上面提到的 Sourcegraph 的搜索，被骗了！我以为是 VSCode 自带的搜索！但是还是期待一下后续的进度，希望能有一个直链，支持类似这样的链接&lt;code&gt;https:&#x2F;&#x2F;github1s.com&#x2F;theowenyoung&#x2F;blog&#x2F;panel&#x2F;search?q=term&amp;amp;files-include=content&lt;&#x2F;code&gt;,这样就可以直接从我的博客里的搜索框跳转到 vscode 的全局搜索里，体验更好。不过这个工具的问题也是首次启动挺慢的，期待微软官方能出一个类似的工具，因为反正 github 也是他家的，可能会更快。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;blog&#x2F;add-search&#x2F;.&#x2F;github1s.png&quot; alt=&quot;githbu1s&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;google-wang-zhan-sou-suo&quot;&gt;Google 网站搜索&lt;a class=&quot;zola-anchor&quot; href=&quot;#google-wang-zhan-sou-suo&quot; aria-label=&quot;Anchor link for: google-wang-zhan-sou-suo&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;你可以在谷歌的搜索框里加上&lt;code&gt;site:www.owenyoung.com&lt;&#x2F;code&gt;来指定搜索对应的网站，速度极快，缺点是可能收录不全。Anyway, 我在&lt;a href=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;search&#x2F;&quot;&gt;Search&lt;&#x2F;a&gt;也添加了一个表单搜索链接了过去，你可以体验一下。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zi-tuo-guan-fang-an&quot;&gt;自托管方案&lt;a class=&quot;zola-anchor&quot; href=&quot;#zi-tuo-guan-fang-an&quot; aria-label=&quot;Anchor link for: zi-tuo-guan-fang-an&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;meilisearch&quot;&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;meilisearch&#x2F;meilisearch&quot;&gt;Meilisearch&lt;&#x2F;a&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#meilisearch&quot; aria-label=&quot;Anchor link for: meilisearch&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;meilisearch&#x2F;meilisearch&quot;&gt;美丽搜索？&lt;&#x2F;a&gt;是一个用 Rust 写的美丽的 Algolia 的开源替代，我喜欢这个名字哈哈哈，美丽！Evething is ok, 就是界面相比 Algolia 还是差了那么一点点。使用流程是在服务端启动服务后，静态博客编译后先请求 meili 的接口，把要索引的文档通通丢给他，然后他就会立刻建立索引，然后客户端可以使用 meili 提供的&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;meilisearch&#x2F;docs-searchbar.js&quot;&gt;客户端 js 库&lt;&#x2F;a&gt;一键接入。我研究了美丽自己的&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.meilisearch.com&#x2F;&quot;&gt;文档网站&lt;&#x2F;a&gt; (&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;meilisearch&#x2F;documentation&quot;&gt;源码&lt;&#x2F;a&gt;),发现他的接入流程更美丽，用 Github 的&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;meilisearch&#x2F;documentation&#x2F;blob&#x2F;master&#x2F;.github&#x2F;workflows&#x2F;gh-pages-scraping.yml&quot;&gt;Action&lt;&#x2F;a&gt;去扫描你整个站点的 sitemap 文件，然后做一些简单的配置，就可以美丽的，有层次的索引你整个网站了。本来以为建立索引挺慢的，但是后面发现 1 分钟左右就能扫描完成，可以在&lt;a href=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;search&#x2F;&quot;&gt;Search 页面&lt;&#x2F;a&gt;体验一下这个搜索结果的层次感！（顺便说一下，这些功能 Algolia 都有哈！），这个层次感是我决定采用它的最重要的原因，因为它是针对文章的各种二级，三级标题，以及内容所在的标题区做的更有细节的索引，所以在搜索结果中，可以直接从结果中点击进入到对应文章的部分。核心配置在扫描的地方：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;selectors&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;lvl0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;      &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;selector&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.detail-page .p-category&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;      &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;default_value&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Random&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;lvl1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;      &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;selector&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.detail-page .p-tags&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;      &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;default_value&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Notes&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;lvl2&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.detail-page .entry-title&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;lvl3&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.e-content h2&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;lvl4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.e-content h3&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;text&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;.e-content p, .e-content li&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样的配置的话 meilisearch 建立索引是细节到具体的小标题和段落上的，可以让搜索体验直接上升一个层次。所有配置见&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&#x2F;blob&#x2F;84f139a47658ff31482d4b36ba0acd86f08b071f&#x2F;meilisearch-docs-scraper-config.json&quot;&gt;这里&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wo-de-bu-shu-guo-cheng&quot;&gt;我的部署过程&lt;a class=&quot;zola-anchor&quot; href=&quot;#wo-de-bu-shu-guo-cheng&quot; aria-label=&quot;Anchor link for: wo-de-bu-shu-guo-cheng&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;先在 VPS 上搭建 Meili,见&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;dotfiles&#x2F;blob&#x2F;main&#x2F;modules&#x2F;meilisearch&#x2F;meilisearch.yml&quot;&gt;我的 meilisearch dotfile 配置&lt;&#x2F;a&gt;，并不复杂，是我最喜欢的单一二进制文件，无依赖。&lt;&#x2F;li&gt;
&lt;li&gt;在 Github Actions 的中添加步骤，在网站更新后，立刻爬取整个网站.见&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&#x2F;blob&#x2F;ee82d2d783c3b08b98862a7700a6a29a301e164e&#x2F;.github&#x2F;workflows&#x2F;build.yml#L20-L37&quot;&gt;build.yml&lt;&#x2F;a&gt; 以及&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&#x2F;blob&#x2F;main&#x2F;meilisearch-docs-scraper-config.json&quot;&gt;爬取的配置文件&lt;&#x2F;a&gt;,得益于我上次在&lt;a href=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;en&#x2F;blog&#x2F;indieweb&#x2F;&quot;&gt;Now, I’m in IndieWeb?&lt;&#x2F;a&gt;中给网站的结构添加了很多有用的标记，所以很好定位到我的一级标题，二级标题，分类等, 我在配置中排除了列表页面，让他只爬取文章页。&lt;&#x2F;li&gt;
&lt;li&gt;在前端网页引入相应的 &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&#x2F;blob&#x2F;37de4f670b3b2d28a77e39b1804ce986c99f0a6a&#x2F;templates&#x2F;search.html#L6-L8&quot;&gt;css&lt;&#x2F;a&gt; 和 &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&#x2F;blob&#x2F;37de4f670b3b2d28a77e39b1804ce986c99f0a6a&#x2F;templates&#x2F;search.html#L71-L85&quot;&gt;js 脚本&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Over! 其实说的简单，但是我在建立索引的过程中多次调整了页面中 tag 的层级和 class 以便机器人可以更好的定位到需要的内容（面向机器人编程），最终打磨出来的效果就是：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;blog&#x2F;add-search&#x2F;.&#x2F;meilisearch.png&quot; alt=&quot;meilisearch&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;搜索页面的模版文件&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&#x2F;blob&#x2F;main&#x2F;templates&#x2F;search.html&quot;&gt;在这里&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jie-lun&quot;&gt;结论&lt;a class=&quot;zola-anchor&quot; href=&quot;#jie-lun&quot; aria-label=&quot;Anchor link for: jie-lun&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;虽然目前用 Meilisearch 解决了搜索的问题（而且体验超好），但是还是更喜欢&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;wilsonzlin&#x2F;edgesearch&quot;&gt;Edgesearch&lt;&#x2F;a&gt;的方案，这样我就能把搜索部署在类似 Workers 和 Deno Deploy 的平台上了。我不喜欢 Lambda 和 Vercel 的无服务器，虽然限制更少，但是相应的冷启动有点久，不够纯粹。我的理想方案应该是这样，它是一个通用的站内搜索引擎：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;通过 Fork 一个 Cloudflare Worker 项目即可部署自己的搜索引擎，带一些很少的配置。&lt;&#x2F;li&gt;
&lt;li&gt;这个搜索引擎会暴露一个开始索引的路由，你会给这个路由提供一个配置文件，然后告诉他&lt;code&gt;sitemap&lt;&#x2F;code&gt;文件，以及要索引的区块配置。&lt;&#x2F;li&gt;
&lt;li&gt;这个搜索引擎暴露几个类似 Algolia 的接口让前端可以搜索，以及管理索引。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;基本上就是把我在 meilisearch 上做的事搬到 wasm 上，但是我更喜欢在 cloudflare workers 上部署搜索服务的方案，因为它更简单，更快，更具有扩展性。&lt;&#x2F;p&gt;
&lt;p&gt;我目前是把 Meili 部署在我的一个 4g 内存位于日本的服务器，这台服务器还部署了我很多其他的东西，如果你也想要接入美丽搜索，但是不想自己部署服务端（我懂），可以邮件或者私信我，我告诉你我的 Master Key，然后你也可以利用&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;meilisearch.owenyoung.com&#x2F;&quot;&gt;https:&#x2F;&#x2F;meilisearch.owenyoung.com&#x2F;&lt;&#x2F;a&gt;建立你的博客索引了。但是这是玩具产品，不能保证可用性，后续也可能被替换，但是终止前我会提前通知你～&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="zh">
		<title>迁移博客和Wiki到 Zola</title>
		<published>2022-04-06T00:00:00+00:00</published>
		<updated>2022-04-06T00:00:00+00:00</updated>
		<link rel="alternate" href="https://www.owenyoung.com/blog/migrate-to-zola/" type="text/html"/>
		<id>https://www.owenyoung.com/blog/migrate-to-zola/</id>
		<content type="html">&lt;p&gt;我在之前建立了一个个人的公开 &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;wiki.owenyoung.com&#x2F;&quot;&gt;Wiki&lt;&#x2F;a&gt;和 &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.owenyoung.com&#x2F;&quot;&gt;Blog&lt;&#x2F;a&gt;，这让我养成了记笔记，多写东西的习惯。但是随着时间的增长，我感到维护 2 个 repo 实在有点麻烦，并且由于 Wiki 和博客都是基于&lt;a href=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;blog&#x2F;gatsby-cons&#x2F;&quot;&gt;Gatsby 框架&lt;&#x2F;a&gt;的，更新，维护，还有编译都挺花时间的。&lt;&#x2F;p&gt;
&lt;p&gt;总的来说就是太复杂了，而由于我对自己的&lt;a href=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;blog&#x2F;about-notes&#x2F;&quot;&gt;笔记&#x2F;博客系统&lt;&#x2F;a&gt;是以一生的尺度去设计和维护的，所以我想让它保持简单。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;&lt;strong&gt;所以这个博客现在拥有了以下特性：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;te-xing&quot;&gt;特性&lt;a class=&quot;zola-anchor&quot; href=&quot;#te-xing&quot; aria-label=&quot;Anchor link for: te-xing&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;由&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&#x2F;tree&#x2F;main&#x2F;bin&quot;&gt;单一的二进制文件&lt;&#x2F;a&gt;驱动（为了更简单，我把那个二进制文件直接放在这个 &lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&quot;&gt;repo&lt;&#x2F;a&gt; 里了，所以这个博客相当于是自运行的，不依赖任何外部环境）&lt;&#x2F;li&gt;
&lt;li&gt;这个博客实际上是由&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.getzola.org&#x2F;&quot;&gt;Zola&lt;&#x2F;a&gt;驱动的，Zola 是用 Rust 写的，非常快，目前我的博客在 Github Actions 里从开始到部署完成只需要&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&#x2F;runs&#x2F;5845460900?check_suite_focus=true&quot;&gt;14s&lt;&#x2F;a&gt;，实际构建时间只需要 2s。而之前用 Gatsby 搭建的 Wiki 站点，总共需要&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;wiki&#x2F;runs&#x2F;5684155852?check_suite_focus=true&quot;&gt;4 分钟&lt;&#x2F;a&gt;构建完成, Blog 站点总共要&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;theowenyoung.github.io&#x2F;runs&#x2F;5845524376?check_suite_focus=true&quot;&gt;3m 37s&lt;&#x2F;a&gt;才能完成&lt;&#x2F;li&gt;
&lt;li&gt;所有的样式都在&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&#x2F;blob&#x2F;main&#x2F;static&#x2F;site&#x2F;styles&#x2F;site.css&quot;&gt;一个简单的 CSS 文件里&lt;&#x2F;a&gt;，全是手写的。保持样式文件的简单，有助于后续的持续维护。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;&quot;&gt;同时支持&lt;&#x2F;a&gt;&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;blog&#x2F;&quot;&gt;普通文章&lt;&#x2F;a&gt;，&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;categories&#x2F;notes&#x2F;&quot;&gt;笔记&lt;&#x2F;a&gt;，和&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.owenyoung.com&#x2F;thoughts&#x2F;&quot;&gt;短想法&lt;&#x2F;a&gt;，而且，维护很简单，所有文件都只是&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;blog&#x2F;tree&#x2F;main&#x2F;content&quot;&gt;一个个的 Markdown 文件&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;dui-zola-bu-man-yi-de-dian&quot;&gt;对 Zola 不满意的点&lt;a class=&quot;zola-anchor&quot; href=&quot;#dui-zola-bu-man-yi-de-dian&quot; aria-label=&quot;Anchor link for: dui-zola-bu-man-yi-de-dian&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;Zola 有一些约束和约定俗成的东西，大多数是比较深思熟虑的限制，我最苦恼的一点就是他不支持把 Markdown 里的相对链接转成 html 的链接。相对链接自动转换这一点的限制其实是合理的，我以前写过&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;gatsby-theme-primer-wiki&#x2F;tree&#x2F;main&#x2F;gatsby-relative-path-to-slug&quot;&gt;Gatsby 的插件&lt;&#x2F;a&gt;去转换相对链接，但是逻辑其实很恶心，因为 markdown 的文件层级和 html 的文件层级其实是不一样的，对 markdown 来说是&lt;code&gt;xxx.md&lt;&#x2F;code&gt;,但是对 HTML 来说是 &lt;code&gt;xxx&#x2F;index.html&lt;&#x2F;code&gt;, 但是有的时候又是一样的,比如&lt;code&gt;xxx&#x2F;index.md&lt;&#x2F;code&gt; 同样是 &lt;code&gt;xxx&#x2F;index.html&lt;&#x2F;code&gt;. 所以我的插件转换需要约定不少东西，挺恶心的。而&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.getzola.org&#x2F;documentation&#x2F;content&#x2F;linking&#x2F;#internal-links&quot;&gt;Zola 的办法就很简单粗暴&lt;&#x2F;a&gt;，他刻意不帮你转换这些东西，只替换包含特殊符号的链接，比如&lt;code&gt;@&#x2F;xxx.md&lt;&#x2F;code&gt;，它会把这类链接统一替换按照正确的路径替换，这样就容易多了.&lt;&#x2F;p&gt;
&lt;p&gt;但是像这样&lt;code&gt;[xxx](@&#x2F;xxxm.d)&lt;&#x2F;code&gt;写链接的话，本地文件系统的相互链接就不工作了,编辑器不知道&lt;code&gt;@&lt;&#x2F;code&gt;是什么，这很令人苦恼。&lt;&#x2F;p&gt;
&lt;p&gt;我就这个问题在 Zola 的论坛提了&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;zola.discourse.group&#x2F;t&#x2F;custom-content-dir-or-support-absolute-internal-link&#x2F;1242&quot;&gt;一个替代办法&lt;&#x2F;a&gt;，主要就是不用&lt;code&gt;@&lt;&#x2F;code&gt;做为特殊符号，直接用&lt;code&gt;&#x2F;content&lt;&#x2F;code&gt;作为特殊符号，这样本地链接就其实是一个合法的内部绝对链接，像这样：&lt;code&gt;[xxx](&#x2F;content&#x2F;xxx.md)&lt;&#x2F;code&gt;，但是 Zola 还没接受我的请求，所以我&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;theowenyoung&#x2F;zola&quot;&gt;改动了 Zola 的代码，改动很少，就几行&lt;&#x2F;a&gt;, 现在我可以用 &lt;code&gt;&#x2F;content&#x2F;xxx.md&lt;&#x2F;code&gt;的形式作为内部链接。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ru-he-bian-ji&quot;&gt;如何编辑&lt;a class=&quot;zola-anchor&quot; href=&quot;#ru-he-bian-ji&quot; aria-label=&quot;Anchor link for: ru-he-bian-ji&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;在编辑方面，我在使用&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;code.visualstudio.com&#x2F;&quot;&gt;VSCode&lt;&#x2F;a&gt;配合我开发的&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=theowenyoung.foam-lite-vscode&quot;&gt;Markdown 输入插件 Foam Lite&lt;&#x2F;a&gt;来编辑这个博客的所有内容。我更喜欢文本辅助输入工具，而不希望软件修改我的原文数据格式。这让我更有掌控感以及不被运营商锁定。&lt;&#x2F;p&gt;
&lt;p&gt;试过&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;obsidian.md&#x2F;&quot;&gt;Obsidian&lt;&#x2F;a&gt;几次，很喜欢他的一些实用的功能，但是发现他的性能还是和 VS Code 差很多的。所以还是用回了 VSCode，然后把最需要的 Obsidian 功能：快捷输入内部文档的 Markdown 链接，改写了一个 VSCode 插件&lt;a rel=&quot;noopener nofollow noreferrer&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=theowenyoung.foam-lite-vscode&quot;&gt;Foam Lite&lt;&#x2F;a&gt;解决了。&lt;&#x2F;p&gt;
&lt;p&gt;这个插件目前只拥有 2 个功能，一个是快捷生成内部链接的地址：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;i.imgur.com&#x2F;sYmKeKO.gif&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;另一个就是快速从模版生成初始文章。&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
